# MORSE_DECODE
## Задача распознавания сигнала Морзе.
В рамках стажировочного задания предоставлен датасет из 30000 аудиофайлов, длиной в 8 секунд.
В аудиофайле находится сигнал Морзе на фоне шума, параметры сигнала и шума варируются.
Также предоставлен .csv-файл, в котором каждому аудиофайлу сопоставлен набор символов точной расшифровки.
Необходимо написать модель машинного обучения, способную расшифровать аудиофайлы.

### Весь код представлен в Morse_Decode_notebook.ipynb

## Решение:
Были проанализированы данные датасета, найдены 44 класса, включая специальный символ '#', шифруемый --.--
Все классы имеют приблизительно одинаковое количество экземпляров в датасете:
![image](https://github.com/user-attachments/assets/5585b9b2-c991-46d0-89ab-f67b687836b4)

Для каждого аудиофайла была построена мел-спектрограмма, её значения возведены в квадрат и нормализованы.
После чего выбран 1 канал с наибольшей амплитудой звучания, итоговая размерность тренировочного экземпляра - (345,)
![image](https://github.com/user-attachments/assets/1df5cf4d-304a-4f1d-a3c7-18da8d6fc4e4)

Разработана архитектура нейронной сети CNN + GRU, CNN должна извлекать признаки из сигнала, а GRU - улавливать долгосрочные зависимости (например, буквенные/словесные структуры). 

Структура модели:

Вход (input) Форма: (B, 1, 345) Тип: одномерный сигнал длины 345, нормализованный, с одним каналом B — размер батча 1 — канал (одномерный сигнал) 345 — длина входного сигнала

CNN-блок (self.cnn) Сверточная часть извлекает пространственные признаки из сигнала: Conv1d(1, 32, kernel_size=5, padding=2) MaxPool1d(2) → длина сигнала: 345 → 172 Conv1d(32, 64, kernel_size=3, padding=1) MaxPool1d(2) → длина сигнала: 172 → 86 Итого: На выходе: (B, 64, 86) — 64 признака на каждом из 86 временных шагов.

GRU-блок (self.gru) Двухслойная, двунаправленная рекуррентная сеть: Вход: (B, 86, 64) Выход: (B, 86, 256) 128 скрытых единиц * 2 (вперёд + назад)

Классификатор (self.classifier) Linear(256, num_classes + 1) +1 класс для CTC (для "blank") Применяется к каждому временному шагу (после GRU)

Выход (output) Форма: (B, 86, num_classes + 1) Это логарифмы вероятностей (log_softmax) по всем классам для каждого временного шага

На выход применяем СТС-декодинг

Итоговый loss составил 0.074 за 10 эпох обучения модели.
loss по расстоянию Левейнштейна на тестовой выборке составил 0.2768.
![image](https://github.com/user-attachments/assets/e9bd1363-824c-41fa-92ec-0f404e14d5c9)

## Датасеты:
Предобработанный:
- сигналы (https://drive.google.com/file/d/1S3MaCbA2RpkcS0gjr8DnyvgfuAGiGX2t/view?usp=drive_link)
- таргеты (https://drive.google.com/file/d/1vM1WXRVm4uy7DMT97p6KOWqhAA5WMZ2I/view?usp=drive_link)

Исходный (https://drive.google.com/file/d/1Qc1rkbW95rDunRwuT0IN-iMY_AjVzeP4/view?usp=sharing)
## Как запустить:

### Вариант 1 - main.py:
-клонировать репозиторий;
-Папка tg_project:
-установить необходимые версии библиотек из requirements.txt (версия python - 3.10);
- создать пустой телеграм-бот (можно через BotFather) / использовать @secret_keys_of_films_ok_bot;
- в файле .env вставить токен своего бота (пропустить если используешь @secret_keys_of_films_ok_bot);
- запустить main.py
- запустить телеграм-бота (/start)
- загрузить аудиофайл с морзянкой (длина аудиозаписи - 8 секунд)
- готово! бот пришлёт расшифровку сигнала

### Вариант 2 - при помощи Docker:
- скачать morse-bot.tar (Ссылка: https://drive.google.com/file/d/1sooWUoRfc9D0dtKZeaVOIkNILwShbv6W/view?usp=drive_link)
- открыть консоль, перейти в директорию с morse-bot.tar
- запустить команды:
- docker load -i morse-bot.tar
- docker run -e BOT_TOKEN=YOUR_TOKEN -p 8000:8000 morse-bot
- готово! бот будет запущен

